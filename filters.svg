<svg xmlns="http://www.w3.org/2000/svg">
  <!-- set filter area to filtered element's dimensions -->
  <filter id="contrast-o-vision" x="0" y="0" width="1" height="1">

    <!-- STEP 1: Convert each pixel to its luminance

         This feColorMatrix shorthand converts each pixel to rgba(0,0,0, X),
         where X is the pixel's luminance. This should match the official WCAG
         algorithm: https://www.w3.org/TR/WCAG20/relative-luminance.xml

         The first operation in the WCAG algorithm when each color component
         is â‰¤0.03928 appears to be the conversion from sRGB to linear RGB, so
         as long as we specify `color-interpolation-filters="linearRGB"` like
         above, this should be equivalent.
      -->
    <feColorMatrix in="SourceGraphic"
                   type="luminanceToAlpha"
                   result="LUMINANCE"/>

    <!-- Possible tweak: slight blur to iron out irregularities -->

    <!-- STEP 2: Find high-contrast edges between pixel luminances

         This particular convolution matrix kernel is known as an "Edge
         Detect", which you may have used in a graphics editor. It displays
         lines more vividly when the contrast between two adjacent pixels
         is high.

         It would be nice to know if it can be tweaked to exaggerate/soften
         its output.

         Other possible matrices:
           kernelMatrix=" 1 -2  1
                         -2  4 -2
                          1 -2  1"
    -->
    <feConvolveMatrix in="LUMINANCE"
                      kernelMatrix="1  1  1
                                    1 -8  1
                                    1  1  1"
                      result="EDGES"/>

    <!-- STEP 3: Hide all edges too faint to meet contrast requirements

        This filter operation should clamp each pixel to either full opacity
        or full transparency; whichever it's closest to. Edges too faint to
        match the WCAG requirements should vanish. -->
    <feComponentTransfer in="EDGES"
                         result="VALID_EDGES">
      <feFuncA type="discrete"
               tableValues="0 1"/> <!-- Locks opacity to either 0 or 1 -->
    </feComponentTransfer>

    <!-- Change the black pixels to be green instead -->
    <feColorMatrix in="VALID_EDGES"
                   type="matrix"
                   values="1  0  0  0  -1
                           0  1  0  0   0.8
                           0  0  1  0   0.2
                           0  0  0  1   0"
                   result="INVERTED_VALID_EDGES"/>


    <!-- Generate a very dark overlay color -->
    <feFlood flood-color="rgba(0, 0, 0, 0.92)"
             result="PARTIALLY_TRANSPARENT_BLACK"/>

    <!-- Mix that color with the original image, producing a dimmed version -->
    <feBlend in="PARTIALLY_TRANSPARENT_BLACK"
             in2="SourceGraphic"
             result="DIMMED_ORIGINAL_ELEMENT"/>

    <!-- Overlay the edges on top of the dimmed element -->
    <feMerge>
      <feMergeNode in="DIMMED_ORIGINAL_ELEMENT"/>
      <feMergeNode in="INVERTED_VALID_EDGES"/>
    </feMerge>
  </filter>
</svg>
