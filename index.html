<!doctype html>
<html lang="en">
<meta charset="utf-8">
<title>Contrast-O-Vision</title>
<meta name="viewport" content="width=device-width,initial-scale=1,minimum-scale=1,shrink-to-fit=no">
<meta name="theme-color" content="#000">

<link rel="stylesheet" href="./kit/site.css">
<link rel="stylesheet" href="./kit/ui.css">
<script defer src="./kit/ui.js"></script>

<menu class="ui">
  <form class="ui__url-bar" target="testframe" action="https://httpbin.org/redirect-to">
    <p class="url-bar__field field--url">
      <label class="field__label--url">
        <span class="visually-hidden">Check URL:</span>

        <input name="url" class="input--url"
               type="url" required
               autocomplete="off"
               placeholder="about:contrast-o-vision"
               title="Please enter a valid URL."
               x-moz-errormessage="Please enter a valid URL.">
      </label>
    </p>

    <p class="url-bar__field field--go">
      <button type="submit" class="btn btn--go">Go</button>
    </p>

    <p class="url-bar__field field--refresh">
      <button type="button" class="btn--refresh"
        aria-label="Refresh" title="Refresh">
        <svg viewBox="0 0 180 180" width="1em" height="1em" class="refresh__svg">
          <path fill="none" stroke="currentColor" stroke-width="26"
            d="M140 135a67 67 0 1 1 0-90m9 0l-20 20h30V35z"/>
        </svg>
      </button>
    </p>
  </form>
</menu>

<main>
  <iframe name="testframe" class="test-frame" src="./kit/intro.html"
    title="Page currently being tested"></iframe>
</main>

<svg height="1" width="1" class="filter-svg">
  <!-- set filter area to filtered element's dimensions -->
  <filter id="contrast-o-vision" x="0" y="0" width="1" height="1">

    <!-- STEP 1: Convert each pixel based on its luminance

         This feColorMatrix shorthand converts each pixel to rgba(0,0,0, X),
         where X is the pixel's luminance. This should match the official WCAG
         algorithm: https://www.w3.org/TR/WCAG20/relative-luminance.xml

         The first operation in the WCAG algorithm when each color component
         is â‰¤0.03928 appears to be the conversion from sRGB to linear RGB, so
         as long as we specify `color-interpolation-filters="linearRGB"` like
         above, this should be equivalent.
      -->
    <feColorMatrix in="SourceGraphic"
                   type="luminanceToAlpha"
                   result="LUMINANCE"/>

    <!-- Possible tweak: slight blur to iron out irregularities -->

    <!-- STEP 2: Find high-contrast edges between pixel luminances

         This particular convolution matrix kernel is known as an "Edge
         Detect", which you may have used in a graphics editor. It displays
         lines more vividly when the contrast between two adjacent pixels
         is high.

         It would be nice to know if it can be tweaked to exaggerate/soften
         its output.

         Other possible matrices:
           kernelMatrix=" 1 -2  1
                         -2  4 -2
                          1 -2  1"
    -->
    <feConvolveMatrix in="LUMINANCE"
                      kernelMatrix="1  1  1
                                    1 -8  1
                                    1  1  1"
                      result="EDGES"/>

    <!-- STEP 3: Hide all edges too faint to meet contrast requirements

        This filter operation should "round" each pixel to either full opacity
        or full transparency, depending on which one it's closer to. Edges too
        faint to match the WCAG requirements should disappear. -->
    <feComponentTransfer in="EDGES"
                         result="VALID_EDGES">
      <feFuncA type="discrete"
               tableValues="0 1"/> <!-- Locks opacity to either 0 or 1 -->
    </feComponentTransfer>

    <!-- Change the black pixels to be green instead -->
    <feColorMatrix in="VALID_EDGES"
                   type="matrix"
                   values="1  0  0  0  -1
                           0  1  0  0   0.8
                           0  0  1  0   0.2
                           0  0  0  1   0"
                   result="INVERTED_VALID_EDGES"/>


    <!-- Generate a very dark overlay color -->
    <feFlood flood-color="rgba(0, 0, 0, 0.92)"
             result="PARTIALLY_TRANSPARENT_BLACK"/>

    <!-- Mix that color with the original image, producing a dimmed version -->
    <feBlend in="PARTIALLY_TRANSPARENT_BLACK"
             in2="SourceGraphic"
             result="DIMMED_ORIGINAL_ELEMENT"/>

    <!-- Overlay the edges on top of the dimmed element -->
    <feMerge>
      <feMergeNode in="DIMMED_ORIGINAL_ELEMENT"/>
      <feMergeNode in="INVERTED_VALID_EDGES"/>
    </feMerge>
  </filter>
</svg>
